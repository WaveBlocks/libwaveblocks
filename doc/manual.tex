\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{mathtools}
\usepackage{kpfonts}
\usepackage{listings}
\usepackage{svg}
\usepackage{floatrow}
\usepackage[english]{babel}

\def\code#1{\texttt{#1}}
\newtheorem{definition}{Definition}

\begin{document}

\section{Basic Shape}

A \(D\)-dimensional shape \(\mathfrak{K}\) is a set of \emph{unordered} D-dimensional integer-tuples, also referred to as \emph{nodes}.
A shape is suitable for our needs if it satisfies:
\[k \in \mathfrak{K} \Rightarrow \forall k^\star \preceq k \colon k^\star \in \mathfrak{K}\]
That means, if an arbitrary node is part of the shape, then all nodes in the backward cone are part of the shape too.

\subsection{Implementation}

\subsection{Shape Extension}

\begin{definition}
Given a basis shape \( \mathfrak{K} \), the shape extension
\( \overline{\mathfrak{K}} \) is defined by
\begin{equation}
\overline{\mathfrak{K}} := \mathfrak{K} \cup 
\left\{\underline{k}' \colon \underline{k}' = \underline{k} + \underline{e}^d 
\forall d \in \{1,\ldots,D\} \forall \underline{k} \in \mathfrak{K}\right\}
\end{equation}
where \( \underline{e}^d \) is the unit vector in direction \( d \).
\end{definition}

\begin{figure}[ht]
	\centering
	\includesvg[]{shape_extension}
	\caption{basic shape (filled bullets) and its extension (empty bullets)}
\end{figure}

\subsection{Shape Union}

\begin{definition}
Given the shapes \( \mathfrak{K}_1, \ldots \mathfrak{K}_N \), the union of these shapes
is defined by
\begin{equation}
union(\mathfrak{K}_1,\ldots,\mathfrak{K}_N) := \left\{ 
\underline{k} \mid \exists i \in \{1, \ldots, N \} \colon \underline{k} \in \mathfrak{K}_i\right\}
\end{equation}
\end{definition}

\section{Shape Enumeration}

A basic shape just tells you whether it contains a specific node. But
for most algorithms, one needs to associate values with shape nodes. One way to
do that is using a dictionary. But it is simpler to enumerate all nodes in a shape.
This way one is able to keep those values in an array, ordered according to the enumeration.

\begin{definition}
A \( D \)-dimensional shape enumeration \( \mathfrak{K} \) is a 
set of ordered D-dimensional integer-tuples, also referred to as \emph{nodes}. It is a (bijective) mapping that orders all nodes of \( \mathfrak{K} \) and assigns the \(i\)-th node the ordinal \( (i-1) \).
\end{definition}

\subsection{Data Format}
Many algorithms, notable evaluation of a emph{hagedorn wavepacket}, use recursive formulas in the form 
\( c_{\underline{k}} = f(c_{\underline{k}-\underline{e}^1}, \ldots, c_{\underline{k}-\underline{e}^D}) \)
where \( c_{\underline{k}} \) is a value associated with the node \( \underline{k} \)
and where \( \underline{e}^d \) is the unit vector in direction \( d \).
To simplify such algorithms, the class ShapeEnum organizes a shape into \emph{slices}. 
The \( s \)-th slice of a shape \( \mathfrak{K} \) contains all nodes \(
\underline{k} \in \mathfrak{K} \) that satisfy \( \sum_{d=1}^{D} k_d = s \) (Manhattan distance).

\begin{figure}[ht]
	\centering
	\includesvg[]{shape_slicing}
	\caption{basic shape (filled bullets) and the slicing (rounded rectangles)}
\end{figure}

The implementation maintains for each slice an array containing all nodes that are part of the slice. The user can decide at compile-time which multi-index type to use:
 \\ \\ A suitable type must \dots
\begin{itemize}
\item \dots provide the same semantics as \code{std::array<int,D>}.
\item \dots specialize \code{std::less} to perform lexical comparison beginning on first index.
\item \dots specialize \code{std::equal\_to} and \code{std::hash}.
\end{itemize}
All nodes inside a slice are ordered according to \code{std::less} of used multi-index type. Be aware that the implemented shape enumerator currently assumes that \code{std::less} performes lexical comparison. Other than that there is nothing inherent that obligates lexical comparison.

\subsection{Enumerator}
A shape enumerator takes a shape object that describes which nodes it contains. The enumerator converts that shape into a shape enumeration. 
The current shape enumerator expects shape descriptions of the following form:
\begin{description}
\item [Surface] Returns for a given \emph{axis} \(j\) and a given \emph{base node} \( \underline{n} \) the largest element \( k^\star \) that satisfies \( \underline{k}(k^\star) \in \mathfrak{K} \): 
\[ k_i(k^\star) =
\begin{cases}
	n_i,& i \neq j\\
	k^\star, & i = j
	\end{cases}
\]
\item [Bounding Volume] Returns for a given axis \(j\) a (preferably) as small as possible \emph{limit} \( L_j \) such that:
\[ \forall \underline{k} \in \mathfrak{K} \,\colon\; k_j \leq L_j \]
\end{description}

\begin{figure}[!h]
\begin{floatrow}
\ffigbox{
	\includesvg[]{shape_enumerator}
}{\caption{enumerator pass}}
\ffigbox{
	\begin{tabular}{|| c | c || c | c ||}
	\multicolumn{2}{|| c ||}{limit( \( \underline{k}_{base} \) , axis \( k_1 \) ) } &
	\multicolumn{2}{c ||}{limit( \( \underline{k}_{base} \) , axis \( k_2 \) ) } \\
	base node & limit & base node & limit \\
	(?, 0) & 7 & (0, ?) & 7 \\
	(?, 1) & 5 & (1, ?) & 7 \\
	(?, 2) & 4 & (2, ?) & 6 \\
	(?, 3) & 4 & (3, ?) & 5 \\
	(?, 4) & 3 & (4, ?) & 3 \\
	(?, 5) & 3 & (5, ?) & 1 \\
	(?, 6) & 2 & (6, ?) & 0 \\
	(?, 7) & 1 & (7, ?) & 0 \\
	(?, 8) & -1 & (8, ?) & -1 \\
	\end{tabular}
}{\caption{enumerator pass}}
\end{floatrow}
\end{figure}

\begin{figure}[ht]
	\centering
	\includesvg[]{shape_enumerator}
	\caption{enumerator pass}
\end{figure}

\begin{tabular}{|| c | c || c | c ||}
\multicolumn{2}{|| c ||}{limit( \( \underline{k}_{base} \) , axis \( k_1 \) ) } &
\multicolumn{2}{c ||}{limit( \( \underline{k}_{base} \) , axis \( k_2 \) ) } \\
base node & limit & base node & limit \\
(?, 0) & 7 & (0, ?) & 7 \\
(?, 1) & 5 & (1, ?) & 7 \\
(?, 2) & 4 & (2, ?) & 6 \\
(?, 3) & 4 & (3, ?) & 5 \\
(?, 4) & 3 & (4, ?) & 3 \\
(?, 5) & 3 & (5, ?) & 1 \\
(?, 6) & 2 & (6, ?) & 0 \\
(?, 7) & 1 & (7, ?) & 0 \\
(?, 8) & -1 & (8, ?) & -1 \\
\end{tabular}


Notice that you can describe a shape in another way, but you will need to implement an other shape enumerator.

\subsection{Abstract Shape Enumeration}

The file \emph{waveblocks/shape\_enumeration\_base.hpp} provides a interface that is meant to be overridden by different implementations. To represent a multi-index, this interface uses the greatest common denominator \emph{std::array\textless int,D\textgreater}. 

\subsection{Default Shape Enumeration}

The file \emph{waveblocks/shape\_enumeration\_default.hpp} provides a default implementation of a shape enumeration.

\begin{lstlisting}[language=C++, caption={}]
template<dim_t D, class MultiIndex, class S>
class DefaultShapeEnumeration;
\end{lstlisting}

\begin{description}
\item[D] number of dimensions
\item[MultiIndex] type to internally represent multi-indices
\item[S] shape description
\end{description}

\subsubsection{Internal multi-index representation}
The default shape enumeration stores all nodes in a vector. Since using \emph{std::array\textless int,D\textgreater} would use a lot of memory, the default enumeration exposes a template parameter to define a better type. \\ \\ A suitable type must \dots
\begin{itemize}
\item provide the same semantics as \emph{std::array\textless int,D\textgreater}
\item specialize \emph{std::less} to perform lexical comparison
\item specialize \emph{std::equal\_to}
\item specialize \emph{std::hash}
\end{itemize}

\subsubsection{Shape definition}
A shape definition class provides two member functions:

\begin{itemize}
\item
\begin{lstlisting}[language=C++, caption={}]
int limit(dim_t axis) const;
\end{lstlisting}
This member function returns for a given axis \( j \) an as small as possible limit \( L_j \) such that:
\[ \forall \boldsymbol{k} \in \mathfrak{K} \,\colon\; k_j \leq L_j \]

\item
\begin{lstlisting}[language=C++, caption={}]
template<class MultiIndex>
int limit(const MultiIndex &base_node, dim_t axis) const;
\end{lstlisting}
This member function for a given axis \( j \) and a given base node \( \boldsymbol{n} \) (whose \( j \)-th entry is zero)
the largest element \( k^\star \) that satisfies: 
\[ \boldsymbol{k} \in \mathfrak{K}, \;
k_i =
   \begin{cases}
      n_i,& i \neq j\\
      k^\star, & i = j
   \end{cases}
\]

\end{itemize}

\subsubsection{Queries}
The default shape enumeration stores all multi-indices in a vector using lexical ordering. The query \emph{ordinal} \(\rightarrow\) \emph{multi-index} is therefore trivial. The query \emph{multi-index} \(\rightarrow\) \emph{ordinal} is done using binary search. Alternatively this implementation can be forced to use \emph{std::unordered\_map} but performance tests revealed that a dictionary is slightly slower than binary seach.

\section{Homogeneous Wavepackets}


\end{document}

