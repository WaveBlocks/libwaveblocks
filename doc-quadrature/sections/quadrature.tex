\section{Quadrature}

The central building block for evaluating inner products is the calculation of
integrals between wavepackets.
This is done numerically with a quadrature rule, of which there are many
different kinds.


\subsection{Gauss-Hermite Quadrature}
\label{subsec:ghquad}

The basic integration algorithm used in this project is the one-dimensional
Gauss-Hermite quadrature.
Like related rules, this method works by evaluating the integrand function at a
defined set of nodes $\gamma_i$, the values of which are summed up with specific
weights $\omega_i$:

\begin{equation}
  \label{eq:gaussquad}
  \int_{-\infty}^{\infty} g(x) \, dx \approx \sum_{i=1}^{n} f(\gamma_i) \omega_i
\end{equation}

In its basic form, the Gauss-Hermite rule works on special integrals of the
following form:

\begin{equation}
  \int_{-\infty}^{\infty} e^{-x^2} f(x) \, dx
\end{equation}

However, as we require the quadrature to work on general functions,
transformations are done to the usual weights and nodes which is described in
\cite{B_master_thesis}.
The result is a rule in the form of \eqref{eq:gaussquad}.
Figure~\ref{fig:ghexample} shows an example of the node distribution of a
Gauss-Hermite rule.

\begin{figure}
  \center
  \input{figures/gh-rule.tex}
  \caption{45-point Gauss-Hermite nodes and weights}
  \label{fig:ghexample}
\end{figure}

In the implementation of this rule, an auxiliary Python script was made to
automatically generate C++-code with hardcoded tables of nodes and weights for
different orders.

The source code can be found under \path{scripts/create_tables.py} and
\path{waveblocks/gauss_hermite_qr.hpp}.


\subsection{Tensor-Product Quadrature}
\label{subsec:tpquad}

The wavepackets that are processed by WaveBlocks are generally multi-dimensional.
To handle this, tensor products of $D$ one-dimensional quadrature rules can be
built up.

Denoting the $i$-th node-weight-pair of the $d$-th scalar quadrature rule
$(\gamma_i^d,\ \omega_i^d)$, the resulting pair at the multi-index $j = (j_1,
\ldots, j_d)$ for the resulting tensor quadrature rule is:

\begin{equation}
  (\gamma_j,\ \omega_j) = \left(
    \begin{pmatrix} \gamma_{j_1}^1 \\ \vdots \\ \gamma_{j_d}^d \end{pmatrix},
    \ \prod_{d=1}^D \omega_{j_d}^d
  \right)
\end{equation}

A two-dimensional quadrature rule is shown in figure~\ref{fig:tpexample}.

\begin{figure}
  \center
  \input{figures/tp-rule.tex}
  \caption{Tensor-product built from 16- and 25-point Gauss-Hermite rules}
  \label{fig:tpexample}
\end{figure}

The implementation resides in \path{waveblocks/tensor_product_qr.hpp}.


\subsection{Result Caching}

As the node positions and weight values are tabulated with an external script
for Gauss-Hermite Quadrature (\ref{subsec:ghquad}), the code for looking up and
returning those numbers is simple and fast.

However, in the case of Tensor-Product Quadrature (\ref{subsec:tpquad}), some
calculations must be performed to yield these values.
We wish to avoid re-calculating node and weight vectors when the same quadrature
rule is used many times, as is done in the case of wavepacket propagation over
many iterations.

For this reason, the results are only calculated once for a given Tensor-Product
rule, stored and re-used automatically on subsequent queries.
The quadrature functions have been implemented as \texttt{static} methods, with
the rule parameters given as template parameters.
Therefore, the caching is done in \texttt{static} fields.

This has the advantage that the rule only has to be calculated once in the
entire run of the program as long as the quadrature rule is the same, even if it
is invoked in different scopes, without having to pass down an object explicitly
that holds a state.
On the other hand, no clean-up can be done automatically, so a method must be
called manually to free the memory used by the cache.
