\section{Quadrature}

The central building block for evaluating inner products is the calculation of
integrals between wavepackets.
This is done numerically with a quadrature rule, of which there are many
different kinds.


\subsection{Gauss-Hermite Quadrature}
\label{subsec:ghquad}

The basic integration algorithm used in this project is the one-dimensional
Gauss-Hermite quadrature.
Like related rules, this method works by evaluating the integrand function at a
defined set of nodes $\gamma_i$, the values of which are summed up with specific
weights $\omega_i$:

\begin{equation}
  \label{eq:gaussquad}
  \int_{-\infty}^{\infty} g(x) \, dx \approx \sum_{i=1}^{n} f(\gamma_i) \omega_i
\end{equation}

In its basic form, the Gauss-Hermite rule works on special integrals of the
following form:

\begin{equation}
  \int_{-\infty}^{\infty} e^{-x^2} f(x) \, dx
\end{equation}

However, as we require the quadrature to work on general functions,
transformations are done to the usual weights and nodes which is described in
\cite{B_master_thesis}.
The result is a rule in the form of \eqref{eq:gaussquad}.
Figure~\ref{fig:ghexample} shows an example of the node distribution of a
Gauss-Hermite rule.

\begin{figure}
  \center
  \input{figures/gh-rule.tex}
  \caption{45-point Gauss-Hermite nodes and weights.}
  \label{fig:ghexample}
\end{figure}

For the implementation of this rule, an auxiliary Python script was made to
automatically generate C++-code with hardcoded tables of nodes and weights for
different orders.

The source code can be found under \path{scripts/create_tables.py} and
\path{waveblocks/gauss_hermite_qr.hpp}.


\subsection{Tensor-Product Quadrature}
\label{subsec:tpquad}

The wavepackets that are processed by WaveBlocks are generally multi-dimensional.
To handle this, tensor products of $D$ one-dimensional quadrature rules can be
built up.

Denoting the $i$-th node-weight-pair of the $d$-th scalar quadrature rule
$(\gamma_i^d,\ \omega_i^d)$, the resulting pair at the multi-index $\vect{j} =
(j_1, \ldots, j_d)$ for the resulting tensor quadrature rule is:

\begin{equation}
  (\gamma_{\vect{j}},\ \omega_{\vect{j}}) = \left(
    \begin{pmatrix} \gamma_{j_1}^1 \\ \vdots \\ \gamma_{j_d}^d \end{pmatrix},
    \ \prod_{d=1}^D \omega_{j_d}^d
  \right)
\end{equation}

A two-dimensional quadrature rule is shown in figure~\ref{fig:tpexample}.

\begin{figure}
  \center
  \input{figures/tp-rule.tex}
  \caption{Tensor-product built from 16- and 25-point Gauss-Hermite rules.}
  \label{fig:tpexample}
\end{figure}

The implementation resides in \path{waveblocks/tensor_product_qr.hpp}.


\subsection{Genz-Keister Quadrature}
\label{subsec:gkquad}

If one wants to investigate higher dimensions, the tensor rule quickly becomes
unfeasible to compute in its full form.
As the results in section~\ref{sec:results} will show, the run-times grow
faster than exponentially with increasing dimensionality, single quadratures
taking minutes already in the fourth dimension.

For this reason, specialized multi-dimensional schemes, such as the Genz-Keister
quadrature implemented here, operate on a reduced set of nodes.
The details of the procedure are outlined in \cite{B15_601}.
Similarly to the Gauss-Hermite quadrature rule, many of the intermediary
constants were tabulated beforehand.

Comparing figures \ref{fig:speedupnd} and \ref{fig:speedupgenzkeister}, one can
see a difference of an order of magnitude between the computational complexity
of tensor and Genz-Keister quadrature.
However, the latter can yield less exact results, so the Genz-Keister level has
to be chosen suitably.


\subsection{Implementation Details}



\subsection{Result Caching}
\label{subseq:resultcaching}

As the node positions and weight values are tabulated with an external script
for Gauss-Hermite quadrature (\ref{subsec:ghquad}), the code for looking up and
returning those numbers is simple and fast.

However, in the case of tensor-product quadrature (\ref{subsec:tpquad}), some
calculations must be performed to yield these values.
We wish to avoid re-calculating node and weight vectors when the same quadrature
rule is used many times, as is done in the case of wavepacket propagation over
many timesteps.

For this reason, the results are only calculated once for a given tensor-product
rule, stored and re-used automatically on subsequent queries.
The quadrature functions have been implemented as \texttt{static} methods, with
the rule parameters given as template parameters.
Therefore, the caching is done in \texttt{static} fields.

This has the advantage that the rule only has to be calculated once in the
entire run of the program as long as the quadrature rule is the same, even if it
is invoked in different scopes, without having to pass down an object explicitly
that holds a state.
On the other hand, no clean-up can be done automatically, so a method must be
called manually to free the memory used by the cache.
