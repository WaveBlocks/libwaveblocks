\section{Results}

Since one of the main reasons of porting WaveBlocks from Python to C++ was to
increase the performance, run-times for various use-cases must be measured and
compared to evaluate the improvements.
All tests were done using homogeneous \texttt{quadrature} with an identity
operator.
The computer used for benchmarking had a quad-core Intel i5-2500 processor.

Different parameters were varied to compare the scaling behaviors of the two
implementations.
Because the algorithms used in both cases were essentially the same, the
run-times grow with the parameters roughly at the same rate, however there is a
big difference in the absolute durations.

\begin{figure}
  \center
  \input{figures/speedup-one-dim.tex}
  \caption{Run-times for 1-D homogeneous quadrature of order 8}
  \label{fig:speedup1d}
\end{figure}

In the simplest test, the number of coefficients of a wavepacket was changed
for a one-dimensional, single-component quadrature.
The results in figure~\ref{fig:speedup1d} show a huge improvement in the C++
version with a speed-up of factor 50 for smaller problems, converging to a
factor of about 9 for larger ones.

\begin{figure}
  \center
  \input{figures/speedup-multi-dim.tex}
  \caption{Run-times for multi-dimensional homogeneous quadrature of order 8
    with 10 coefficients per dimension}
  \label{fig:speedupnd}
\end{figure}

The next test inspects the impact of dimensionality.
As can be seen from figure~\ref{fig:speedupnd}, higher-dimensional problems can
have a 20-fold speedup.

\begin{figure}
  \center
  \input{figures/speedup-multi-comp.tex}
  \caption{Run-times for multi-component 2-D homogeneous quadrature of order 8
    with 10 coefficients per dimension}
  \label{fig:speedupncomps}
\end{figure}

Finally, figure~\ref{fig:speedupncomps} shows the behavior for varying sizes
of multi-component wavepackets.
It is apparent that the speed-up is very consistently a factor of approximately
75.

In conclusion, there is no doubt that replacing the quadrature code with a C++
version using the highly-optimized Eigen library brings great improvements.
However, it must be noted that these are isolated measurements and the speed-up
is only significant if a large part of the execution time is spent in the
quadrature.
This means that for smaller problems, even though the measured speed-ups are
huge, there are probably bottlenecks in other parts of the code, which
diminishes the total improvement.

Additionally, a noticeable trade-off is a much longer compilation time, which
can hinder doing many test with small problems.
If one wants to tweak some hard-coded parameter, they have to wait for the
lengthy build to finish.
Disabling optimization flags can help, but in this aspect the Python version has
a clear advantage.

Beyond the efficiency improvements, using a statically typed language can also
aid with catching more bugs at compilation time, theoretically resulting in more
correct programs.
Unfortunately, compiler error messages can get very complicated and confusing
when using template-heavy C++ code like in this work, so some experience is
needed to find and fix bugs.
